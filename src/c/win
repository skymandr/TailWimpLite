/*  File: win.c
 *  Part of TailWimp Lite
 *  Copyright (C) 2021  Andreas Skyman (Bumbarrel Computing)
 * 
 *  Many features in this program are highly derivative of Steve Fryatt's
 *  examples from http://www.stevefryatt.org.uk/risc-os/wimp-prog which
 *  have been relicensed from European Union Public License v1.2 for the
 *  purpose of this program.
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <string.h>

#include "oslib/wimp.h"
#include "oslib/wimpspriteop.h"

#include "choices.h"
#include "screen.h"
#include "tailwimp.h"
#include "win.h"


// Global variables
static wimp_w win_handle;
#define WIN_TITLE_TEXT_LEN 14
static char win_title_text[WIN_TITLE_TEXT_LEN];


// Function prototypes:
static wimp_i win_create_icon(void);
static void window_to_centre(wimp_window_state* state);
static void window_to_off_screen(wimp_window_state* state);
static void window_to_left(
    wimp_window_state*  state,
    screen_padding*     pad
);
static void window_to_right(
    wimp_window_state*  state,
    screen_padding*     pad
);
static void window_to_top(
    wimp_window_state*  state,
    screen_padding*     pad
);
static void window_to_bottom(
    wimp_window_state*  state,
    screen_padding*     pad
);
static void window_max_width(
    wimp_window_state*  state,
    screen_padding*     pad
);
static void window_max_height(
    wimp_window_state*  state,
    screen_padding*     pad
);
static osbool window_is_left(
    wimp_window_state*  state,
    screen_padding*     pad
);
static osbool window_is_right(
    wimp_window_state*  state,
    screen_padding*     pad
);
static osbool window_is_top(
    wimp_window_state*  state,
    screen_padding*     pad
);
static osbool window_is_bottom(
    wimp_window_state*  state,
    screen_padding*     pad
);


// Windoww initialisation:
void win_initialise(void) {
    wimp_window window_definition;

    window_definition.visible.x0 =   0;
    window_definition.visible.x1 = 320;
    window_definition.visible.y0 =   0;
    window_definition.visible.y1 = 320;
    window_definition.xscroll = 0;
    window_definition.yscroll = 0;
    window_definition.next = wimp_TOP;
    window_definition.flags = wimp_WINDOW_NEW_FORMAT
                              | wimp_WINDOW_MOVEABLE
                              | wimp_WINDOW_AUTO_REDRAW
                              | wimp_WINDOW_BOUNDED_ONCE
                              | wimp_WINDOW_BACK_ICON
                              | wimp_WINDOW_CLOSE_ICON
                              | wimp_WINDOW_TITLE_ICON
                              | wimp_WINDOW_TOGGLE_ICON
                              | wimp_WINDOW_VSCROLL
                              | wimp_WINDOW_SIZE_ICON
                              | wimp_WINDOW_HSCROLL
                              | wimp_WINDOW_NO_BOUNDS
                              | wimp_WINDOW_HOT_KEYS;
    window_definition.title_fg = wimp_COLOUR_BLACK;
    window_definition.title_bg = wimp_COLOUR_LIGHT_GREY;
    window_definition.work_fg = wimp_COLOUR_BLACK;
    window_definition.work_bg = wimp_COLOUR_CREAM;
    window_definition.scroll_outer = wimp_COLOUR_MID_LIGHT_GREY;
    window_definition.scroll_inner = wimp_COLOUR_VERY_LIGHT_GREY;
    window_definition.highlight_bg = wimp_COLOUR_CREAM;
    window_definition.extra_flags = 0;
    window_definition.extent.x0 =     0;
    window_definition.extent.x1 =  1000;
    window_definition.extent.y0 = -1000;
    window_definition.extent.y1 =     0;
    window_definition.title_flags = wimp_ICON_TEXT
                                    | wimp_ICON_BORDER 
                                    | wimp_ICON_HCENTRED
                                    | wimp_ICON_VCENTRED
                                    | wimp_ICON_FILLED
                                    | wimp_ICON_INDIRECTED;
    window_definition.title_data.indirected_text.text = win_title_text;
    window_definition.title_data.indirected_text.size = WIN_TITLE_TEXT_LEN;
    window_definition.title_data.indirected_text.validation = "";
    window_definition.work_flags = wimp_BUTTON_NEVER
                                   << wimp_ICON_BUTTON_TYPE_SHIFT;
    window_definition.sprite_area = wimpspriteop_AREA;
    window_definition.xmin = 0;
    window_definition.ymin = 0;
    window_definition.icon_count = 0;

    strncpy(win_title_text, APP_TITLE, WIN_TITLE_TEXT_LEN);
    win_title_text[WIN_TITLE_TEXT_LEN - 1] = '\0';

    win_handle = wimp_create_window(&window_definition);
    win_create_icon();
}


// Open the window:
void win_open(void) {
    wimp_window_state state;

    // Get window state:
    state.w = win_handle;
    wimp_get_window_state(&state);

    // Set window position:
    if (!(state.flags & wimp_WINDOW_OPEN)) {
        window_to_centre(&state);
    }
    state.next = wimp_TOP;

    // Open window:
    wimp_open_window((wimp_open*) &state);
}


// Create icon in window:
static wimp_i win_create_icon(void) {
    wimp_icon_create icon_definition;

    icon_definition.w = win_handle;
    icon_definition.icon.extent.x0 =   60;
    icon_definition.icon.extent.x1 =  260;
    icon_definition.icon.extent.y0 = -260;
    icon_definition.icon.extent.y1 =  -60;
    icon_definition.icon.flags = wimp_ICON_SPRITE
                                | wimp_ICON_HCENTRED
                                | (wimp_COLOUR_BLACK
                                   << wimp_ICON_FG_COLOUR_SHIFT)
                                | (wimp_COLOUR_CREAM
                                   << wimp_ICON_BG_COLOUR_SHIFT);
    strncpy(
        icon_definition.icon.data.sprite,
        "bumbarrelbbl",
        osspriteop_NAME_LIMIT
    );

    return wimp_create_icon(&icon_definition);
}


//////////////////////////////////
/* Window interaction functions */
//////////////////////////////////

// Window is on the left of the screen:
static osbool window_is_left(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    return state->visible.x0 - pad->left == 0;
}


// Window is on the right of the screen:
static osbool window_is_right(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;
    
    screen_get_dim(&dimensions);

    // I would like this to be:
    // return state->visible.x1 + pad.right == dimensions.width;
    // but that will require some extra error handling in to_right...
    return state->visible.x0 == (dimensions.width - pad->left - pad->right) / 2
                                + pad->left;
}


// Window is at the top of the screen:
static osbool window_is_top(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    return state->visible.y1 + pad->top == dimensions.height;
}


// Window is at the bottom of the screen:
static osbool window_is_bottom(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    // I would like this to be:
    // return state->visible.y0 - pad.bottom == 0;
    // but that will require some extra error handling/logic in to_bottom...
    return state->visible.y1 == (dimensions.height - pad->top - pad->bottom)/ 2
                                + pad->bottom;
}


// Centre window on screen:
static void window_to_centre(wimp_window_state* state) {
    screen_dim  dimensions;
    int         width, height;

    width = state->visible.x1 - state->visible.x0;
    height = state->visible.y1 - state->visible.y0;

    screen_get_dim(&dimensions);

    state->visible.x0 = (dimensions.width - width) / 2;
    state->visible.y0 = (dimensions.height - height) / 2;

    state->visible.x1 = state->visible.x0 + width;
    state->visible.y1 = state->visible.y0 + height;
}


// Put window off screen:
static void window_to_off_screen(wimp_window_state* state) {
    int width, height;

    width = state->visible.x1 - state->visible.x0;
    height = state->visible.y1 - state->visible.y0;

    state->visible.x0 = -(width + 42);
    state->visible.y0 = -(height + 42);

    state->visible.x1 = state->visible.x0 + width;
    state->visible.y1 = state->visible.y0 + height;
}


// Move window to the left of the screen:
static void window_to_left(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    state->visible.x0 == pad->left;
    state->visible.x1 == (dimensions.width - pad->left - pad->right) / 2
                         + pad->left;
};


// Move window to the right of the screen:
static void window_to_right(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    // This should ideally check that this is possible with max dimensions and
    // pad x0 if not:
    state->visible.x0 == (dimensions.width - pad->left - pad->right) / 2
                         + pad->left;
    state->visible.x1 == dimensions.width - pad->right;
};


// Move window to the top of the screen:
static void window_to_top(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    state->visible.y0 == (dimensions.height - pad->top - pad->bottom) / 2
                         + pad->bottom;
    state->visible.y1 == dimensions.height - pad->right;
}


// Move window to the bottom of the screen:
static void window_to_bottom(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    state->visible.y0 == pad->bottom;
    // This should ideally check that this is possible with max dimensions and
    // pad y1 if not:
    state->visible.y1 == (dimensions.height - pad->top - pad->bottom) / 2
                         + pad->bottom;
}


// Mazimize window width:
static void window_max_width(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    state->visible.x0 == pad->left;
    state->visible.x1 == dimensions.width - pad->right;
};


// Mazimize window height:
static void window_max_height(
    wimp_window_state*  state,
    screen_padding*     pad
) {
    screen_dim dimensions;

    screen_get_dim(&dimensions);

    state->visible.y0 == pad->bottom;
    state->visible.y1 == dimensions.height - pad->top;
};